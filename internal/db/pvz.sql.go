// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: pvz.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPVZ = `-- name: CreatePVZ :one
INSERT INTO pvz (
    city
) VALUES (
    $1
)
RETURNING id, registration_date, city
`

type CreatePVZRow struct {
	ID               uuid.UUID    `db:"id" json:"id"`
	RegistrationDate sql.NullTime `db:"registration_date" json:"registration_date"`
	City             string       `db:"city" json:"city"`
}

func (q *Queries) CreatePVZ(ctx context.Context, city string) (CreatePVZRow, error) {
	row := q.queryRow(ctx, q.createPVZStmt, createPVZ, city)
	var i CreatePVZRow
	err := row.Scan(&i.ID, &i.RegistrationDate, &i.City)
	return i, err
}

const getPVZsWithReceptions = `-- name: GetPVZsWithReceptions :many
WITH pvz_paginated AS (
    SELECT id, registration_date, city
    FROM pvz
    ORDER BY registration_date DESC, id
    LIMIT $3 OFFSET (($4 - 1) * $3)
),
reception_data AS (
    SELECT 
        r.pvz_id,
        r.id AS reception_id,
        r.date_time,
        r.status,
        (SELECT json_agg(json_build_object(
            'id', p.id,
            'dateTime', p.date_time,
            'type', p.type,
            'receptionId', p.reception_id
        ) ORDER BY p.sequence DESC)
        FROM products p
        WHERE p.reception_id = r.id
        ) AS products
    FROM receptions r
    WHERE 
        r.date_time BETWEEN COALESCE($1, '-infinity'::timestamp) 
                         AND COALESCE($2, 'infinity'::timestamp)
        AND r.pvz_id IN (SELECT id FROM pvz_paginated)
)
SELECT 
    p.id AS pvz_id,
    p.registration_date,
    p.city,
    COALESCE(
        (SELECT json_agg(json_build_object(
            'reception', json_build_object(
                'id', rd.reception_id,
                'dateTime', rd.date_time,
                'status', rd.status,
                'pvzId', rd.pvz_id
            ),
            'products', rd.products
        )) FROM reception_data rd WHERE rd.pvz_id = p.id),
        '[]'::json
    )::text AS receptions_json
FROM pvz_paginated p
`

type GetPVZsWithReceptionsParams struct {
	DateTime   sql.NullTime `db:"date_time" json:"date_time"`
	DateTime_2 sql.NullTime `db:"date_time_2" json:"date_time_2"`
	Limit      int32        `db:"limit" json:"limit"`
	Column4    interface{}  `db:"column_4" json:"column_4"`
}

type GetPVZsWithReceptionsRow struct {
	PvzID            uuid.UUID    `db:"pvz_id" json:"pvz_id"`
	RegistrationDate sql.NullTime `db:"registration_date" json:"registration_date"`
	City             string       `db:"city" json:"city"`
	ReceptionsJson   string       `db:"receptions_json" json:"receptions_json"`
}

func (q *Queries) GetPVZsWithReceptions(ctx context.Context, arg GetPVZsWithReceptionsParams) ([]GetPVZsWithReceptionsRow, error) {
	rows, err := q.query(ctx, q.getPVZsWithReceptionsStmt, getPVZsWithReceptions,
		arg.DateTime,
		arg.DateTime_2,
		arg.Limit,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPVZsWithReceptionsRow
	for rows.Next() {
		var i GetPVZsWithReceptionsRow
		if err := rows.Scan(
			&i.PvzID,
			&i.RegistrationDate,
			&i.City,
			&i.ReceptionsJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
